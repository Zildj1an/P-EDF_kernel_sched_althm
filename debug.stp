/*
  Printea info de llamdas y returns per-thread cronometrada.
  Hace tracing del primer parametro. Mientras el primero parametro triggea la funcion trace,
  esta solo hara print en caso de que nos encontremos en un thread nested dentro de la invocacion del segundo parametro,
  o de que no haya segundo parametro (es opcional)

  Un ejemplo de uso:
	$ sudo stap -v debug.stp 'process("/bin/ls").function("*")' \ 'process("/bin/ls").function("main")' -c "/bin/ls > /dev/null"
*/

probe begin {
	printf("Comienzo del tracing...")
}

function trace(entry_p, extra) {
  %( $# > 1 %? if (tid() in trace) %)
  printf("%s%s cpu = %s%s %s\n", thread_indent (entry_p),(entry_p > 0? "->" : "<-"), cpu(),ppfunc(),extra)
}

%( $# > 1 %?

global trace

probe $2.call {
  trace[tid()] = 1
}

probe $2.return {
  delete trace[tid()]
}

%)

probe $1.call   { trace(1, $$parms) }
probe $1.return { trace(-1, $$return) }

